# def_tables_index_hint

## Описание функции

Функция `_tables_index_hint()` является **критически важной** для создания контекста для LLM (искусственного интеллекта). Она формирует компактную "память" о всех ранее созданных таблицах, позволяя LLM понимать историю работы и строить логичные продолжения.

## Расположение в коде

**Файл:** `app.py`  
**Строки:** 226-251

## Сигнатура функции

```python
def _tables_index_hint() -> str:
```

## Параметры

Функция не принимает параметров. Использует данные из `st.session_state["results"]`.

## Возвращаемое значение

**`str`** - Текстовый каталог всех ранее созданных таблиц в формате:

```
Справка по ранее созданным таблицам:

Таблица 1: Название таблицы
Источник(и): table1, table2; Период: 2024-01-01 — 2024-01-31
SQL:
SELECT column1, column2 FROM table1 WHERE date BETWEEN '2024-01-01' AND '2024-01-31'

Таблица 2: Другая таблица
Источник(и): table3; Период: период не указан
SQL:
SELECT column3, count(*) FROM table3 GROUP BY column3
```

## Алгоритм работы

### 1. Перебор всех результатов
```python
for item in st.session_state.get("results", []):
    if item.get("kind") != "table":
        continue
```
- Извлекает только таблицы из истории результатов
- Игнорирует графики и другие типы результатов
- Обеспечивает фокус на структурированных данных

### 2. Извлечение метаданных
```python
n = _table_number_for(item)           # Номер таблицы
meta = item.get("meta") or {}        # Метаданные
title = (meta.get("title") or "").strip()    # Заголовок
explain = (meta.get("explain") or "").strip() # Объяснение
sql = (meta.get("sql") or "").strip()        # SQL-код
```
- Получает номер таблицы для идентификации
- Извлекает заголовок и объяснение (если есть)
- Берет SQL-код для анализа

### 3. Анализ SQL через _extract_sql_info()
```python
info = _extract_sql_info(sql, None)
src = ", ".join(info.get("tables") or [])    # Источники данных
period = info.get("period") or "период не указан"  # Временной период
```
- Использует функцию `_extract_sql_info()` для парсинга SQL
- Извлекает источники данных (таблицы)
- Определяет временной период запроса

### 4. Формирование описания
```python
head = f"Таблица {n}"
if title:
    head += f": {title}"
lines.append(f"{head}\nИсточник(и): {src or '—'}; Период: {period}\nSQL:\n{sql}\n")
```
- Создает заголовок с номером и названием
- Добавляет информацию об источниках и периоде
- Включает полный SQL-код для контекста

### 5. Обработка пустого результата
```python
if not lines:
    return "Ранее таблицы не создавались."
return "Справка по ранее созданным таблицам:\n\n" + "\n".join(lines)
```
- Возвращает сообщение, если таблиц нет
- Формирует финальный каталог

## Места использования

### 1. Контекст для роутера
```python
router_msgs = (
    [{"role": "system", "content": _tables_index_hint()}] +  # <<< контекст
    [{"role": "system", "content": prompts_map["router"]}] +
    st.session_state["messages"]
)
```
- Перед определением режима работы
- LLM видит все таблицы и может выбрать подходящий режим
- Обеспечивает контекстное принятие решений

### 2. Контекст для SQL-генерации
```python
exec_msgs = (
    [{"role": "system", "content": _tables_index_hint()}] +  # <<< контекст
    [{"role": "system", "content": prompts_map["sql"]}] +
    st.session_state["messages"]
)
```
- Перед генерацией SQL-запросов
- LLM понимает структуру предыдущих запросов
- Может строить новые запросы на основе существующих

### 3. Контекст для RAG-поиска
```python
exec_msgs = (
    [{"role": "system", "content": _tables_index_hint()}] +  # <<< контекст
    [{"role": "system", "content": prompts_map["sql"]}] +
    st.session_state["messages"]
)
```
- Перед RAG-поиском в базе знаний
- LLM знает, какие таблицы уже использовались
- Может предлагать релевантные продолжения

## Типы задач, для которых используется

### 1. **Преемственность диалога**
- Пользователь: "Добавь к предыдущей таблице фильтр по Москве"
- LLM видит: "Таблица 1: Топ городов, Источник: users, Период: 2024-01-01"
- LLM понимает: нужно добавить WHERE city = 'Москва' к существующему запросу

### 2. **Ссылки на конкретные таблицы**
- Пользователь: "Построй график по Таблице 2"
- LLM видит: "Таблица 2: Статистика по регионам, Источник: users, Колонки: region, city, count"
- LLM понимает: нужно создать график по region/city с данными count

### 3. **Логичные продолжения**
- Пользователь: "Покажи детализацию"
- LLM видит: "Таблица 1: Топ городов, Источник: users, Период: январь 2024"
- LLM понимает: нужно показать детализацию по городам за тот же период

### 4. **Контекстные предложения**
- LLM видит историю таблиц и может предлагать:
  - "Добавить временной фильтр"
  - "Сгруппировать по другому полю"
  - "Создать сводную таблицу"

## Примеры работы

### Пример 1: Простая история
```python
# st.session_state["results"] = [
#     {"kind": "table", "meta": {"title": "Топ городов", "sql": "SELECT city, count(*) FROM users GROUP BY city"}}
# ]

result = _tables_index_hint()
# Результат:
# "Справка по ранее созданным таблицам:
# 
# Таблица 1: Топ городов
# Источник(и): users; Период: период не указан
# SQL:
# SELECT city, count(*) FROM users GROUP BY city"
```

### Пример 2: Сложная история
```python
# Несколько таблиц с разными источниками и периодами
result = _tables_index_hint()
# Результат:
# "Справка по ранее созданным таблицам:
# 
# Таблица 1: Топ городов за январь
# Источник(и): users, payments; Период: 2024-01-01 — 2024-01-31
# SQL:
# SELECT city, count(*) FROM users u JOIN payments p ON u.id = p.user_id 
# WHERE p.date BETWEEN '2024-01-01' AND '2024-01-31' GROUP BY city
# 
# Таблица 2: Статистика по регионам
# Источник(и): users; Период: период не указан
# SQL:
# SELECT region, city, count(*) FROM users GROUP BY region, city"
```

## Взаимодействие с другими функциями

### 1. **Использует `_extract_sql_info()`**
```python
info = _extract_sql_info(sql, None)
src = ", ".join(info.get("tables") or [])
period = info.get("period") or "период не указан"
```
- Парсит SQL для извлечения метаданных
- Получает источники и временные периоды
- Обеспечивает структурированную информацию

### 2. **Использует `_table_number_for()`**
```python
n = _table_number_for(item)
```
- Получает порядковый номер таблицы
- Обеспечивает уникальную идентификацию
- Позволяет ссылаться на конкретные таблицы

### 3. **Используется в LLM-запросах**
- Передается как system-сообщение
- Обеспечивает контекст для принятия решений
- Улучшает качество ответов

## Критическая важность

Эта функция является **фундаментальной** для:
- Обеспечения контекста для LLM
- Преемственности диалога
- Улучшения качества ответов
- Создания логичных продолжений
- Поддержки ссылок на предыдущие результаты

## Без этой функции было бы:

❌ **LLM не помнит контекст** - не знает, что было раньше  
❌ **Нет преемственности** - каждый запрос изолирован  
❌ **Плохое качество ответов** - LLM не может строить на предыдущих результатах  
❌ **Нет ссылок** - нельзя ссылаться на конкретные таблицы  
❌ **Ограниченные возможности** - нет контекстных предложений  

## С этой функцией получаете:

✅ **Полный контекст** - LLM видит всю историю работы  
✅ **Преемственность** - может строить на предыдущих результатах  
✅ **Качественные ответы** - понимает структуру данных  
✅ **Ссылки на таблицы** - можно ссылаться по номеру  
✅ **Умные предложения** - контекстные рекомендации  

## Производительность

- **Временная сложность:** O(n) где n - количество таблиц
- **Пространственная сложность:** O(k) где k - общий размер SQL-кодов
- Минимальные накладные расходы
- Кэширование в `session_state`

## Обработка ошибок

- Безопасный доступ к `session_state`
- Обработка отсутствующих метаданных
- Fallback на дефолтные значения
- Устойчивость к некорректным данным

## Альтернативные подходы

### ❌ **Передача всех SQL-кодов**
```python
# Плохо: слишком много информации
all_sql = "\n".join([item["meta"]["sql"] for item in results])
```

### ❌ **Только номера таблиц**
```python
# Плохо: нет контекста
tables = [f"Таблица {i}" for i in range(len(results))]
```

### ✅ **Текущий подход**
- Структурированная информация
- Компактный формат
- Максимальный контекст
- Оптимальное использование токенов

## Практический пример использования

```python
# Пользователь создал несколько таблиц
# 1. "Покажи топ городов по пользователям"
# 2. "Добавь информацию о платежах"
# 3. "Сгруппируй по регионам"

# LLM получает контекст:
context = _tables_index_hint()
# "Справка по ранее созданным таблицам:
# 
# Таблица 1: Топ городов
# Источник(и): users; Период: период не указан
# SQL: SELECT city, count(*) FROM users GROUP BY city
# 
# Таблица 2: Города с платежами
# Источник(и): users, payments; Период: 2024-01-01 — 2024-01-31
# SQL: SELECT city, count(*), sum(amount) FROM users u JOIN payments p ON u.id = p.user_id WHERE p.date BETWEEN '2024-01-01' AND '2024-01-31' GROUP BY city
# 
# Таблица 3: Статистика по регионам
# Источник(и): users, payments; Период: 2024-01-01 — 2024-01-31
# SQL: SELECT region, city, count(*), sum(amount) FROM users u JOIN payments p ON u.id = p.user_id WHERE p.date BETWEEN '2024-01-01' AND '2024-01-31' GROUP BY region, city"

# Пользователь просит: "Построй график по Таблице 2"
# LLM понимает: нужно создать график по city с данными count и sum(amount) за январь 2024
```

**Эта функция - это "мозг" системы, который позволяет LLM понимать контекст и принимать умные решения!**
