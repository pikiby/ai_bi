# def_extract_sql_info

## Описание функции

Функция `_extract_sql_info()` является **критически важной** для парсинга SQL-запросов и извлечения структурированных метаданных. Обеспечивает автоматическое создание подписей, контекст для LLM и каталогизацию результатов в аналитическом приложении.

## Расположение в коде

**Файл:** `app.py`  
**Строки:** 171-200

## Сигнатура функции

```python
def _extract_sql_info(sql: str | None, pdf: pd.DataFrame | None) -> dict:
```

## Параметры

### `sql: str | None` - SQL-запрос для анализа
- Исходный SQL-код для парсинга
- `None` обрабатывается как пустая строка
- **Обязательный параметр**

### `pdf: pd.DataFrame | None` - Результат выполнения запроса
- DataFrame с результатами SQL-запроса
- Используется как fallback для извлечения колонок
- **Опциональный параметр**

## Возвращаемое значение

**`dict`** со структурой:
```python
{
    "tables": [],      # Список таблиц из FROM/JOIN
    "columns": [],     # Список колонок из SELECT
    "period": None,    # Период из WHERE (BETWEEN или даты)
    "limit": None      # Лимит записей из LIMIT
}
```

## Алгоритм работы

### 1. Инициализация и безопасность
```python
if not sql:
    sql = ""
info = {"tables": [], "columns": [], "period": None, "limit": None}
```
- Обработка `None` как пустой строки
- Создание структуры для результатов
- Предотвращение ошибок при пустых данных

### 2. Извлечение таблиц
```python
for pat in [r"\bFROM\s+([a-zA-Z0-9_.`\"]+)", r"\bJOIN\s+([a-zA-Z0-9_.`\"]+)"]:
    info["tables"] += [m.group(1).strip("`\"") for m in re.finditer(pat, sql, flags=re.IGNORECASE)]
```
- Поиск таблиц в `FROM` и `JOIN` клаузулах
- Удаление кавычек и бэктиков
- Регистронезависимый поиск
- Поддержка сложных имен таблиц

### 3. Парсинг колонок из SELECT
```python
m_sel = re.search(r"\bSELECT\s+(.*?)\bFROM\b", sql, flags=re.IGNORECASE | re.DOTALL)
```
- Извлечение секции `SELECT` до `FROM`
- Обработка многострочных запросов
- Поддержка сложных конструкций

### 4. Обработка алиасов
```python
m_as = re.search(r"\bAS\s+([a-zA-Z0-9_`\"]+)\b", p, flags=re.IGNORECASE)
if m_as:
    c = m_as.group(1).strip("`\"")
else:
    c = re.split(r"\s+", p)[-1]
    c = c.split(".")[-1].strip("`\"")
```
- Приоритет алиасам после `AS`
- Fallback на последнее слово
- Обработка `table.column` → `column`
- Удаление служебных символов

### 5. Фильтрация служебных элементов
```python
if c != "*" and re.match(r"^[a-zA-Z0-9_]+$", c or ""):
    cols.append(c)
```
- Исключение `*` и функций
- Только буквенно-цифровые имена
- Предотвращение мусорных данных

### 6. Fallback на DataFrame
```python
if not cols and isinstance(pdf, pd.DataFrame):
    cols = list(pdf.columns[:6])
```
- Если парсинг SQL не удался
- Берет первые 6 колонок из результата
- Обеспечивает работоспособность

## Места использования

### 1. Автоматические подписи к таблицам
```python
info = _extract_sql_info(sql, pdf)
src = ", ".join(info.get("tables") or [])
period = info.get("period") or "период не указан"
st.caption(f"Источник: {src}. Период: {period}.")
```
- **Строка 301** - создание подписей под таблицами
- Показывает источники данных и временные рамки
- Улучшает понимание контекста

### 2. Каталогизация для LLM
```python
info = _extract_sql_info(sql, None)
src = ", ".join(info.get("tables") or [])
period = info.get("period") or "период не указан"
lines.append(f"{head}\nИсточник(и): {src or '—'}; Период: {period}\nSQL:\n{sql}\n")
```
- **Строка 227** - создание каталога таблиц
- LLM видит структуру предыдущих запросов
- Обеспечивает контекст для новых запросов

### 3. Умные заголовки таблиц
```python
info = _extract_sql_info(sql, pdf)
if info.get("limit"):
    lead = None
    for c in info["columns"]:
        if re.search(r"(city|город|category|катег|product|товар|region|регион|name|назв)", c, flags=re.IGNORECASE):
            lead = c; break
    title = f'Топ {info["limit"]}' + (f" по «{lead}»" if lead else "")
```
- **Строка 277** - генерация осмысленных заголовков
- "Топ 10 по «city»" вместо "Результаты запроса"
- Улучшает пользовательский опыт

## Примеры работы

### Пример 1: Простой запрос
```sql
SELECT city, count(*) as cnt FROM users GROUP BY city LIMIT 10
```
**Результат:**
```python
{
    "tables": ["users"],
    "columns": ["city", "cnt"],
    "period": None,
    "limit": 10
}
```
**В интерфейсе:** "Топ 10 по «city»"

### Пример 2: JOIN с периодом
```sql
SELECT u.city, p.amount 
FROM users u 
JOIN payments p ON u.id = p.user_id 
WHERE p.date BETWEEN '2024-01-01' AND '2024-01-31'
```
**Результат:**
```python
{
    "tables": ["users", "payments"],
    "columns": ["city", "amount"],
    "period": "2024-01-01 — 2024-01-31",
    "limit": None
}
```
**В интерфейсе:** "Источник: users, payments. Период: 2024-01-01 — 2024-01-31."

### Пример 3: Сложный запрос
```sql
SELECT 
    u.city as city_name,
    COUNT(*) as user_count,
    AVG(p.amount) as avg_payment
FROM users u
LEFT JOIN payments p ON u.id = p.user_id
WHERE u.created_at >= '2024-01-01'
GROUP BY u.city
ORDER BY user_count DESC
LIMIT 20
```
**Результат:**
```python
{
    "tables": ["users", "payments"],
    "columns": ["city_name", "user_count", "avg_payment"],
    "period": "2024-01-01 — (текущая дата)",
    "limit": 20
}
```

## Зачем это нужно в проекте

### 1. **Контекст для LLM (искусственного интеллекта)**
- LLM видит структуру предыдущих запросов
- Может ссылаться на конкретные таблицы и колонки
- Понимает временные рамки данных
- Строит новые запросы на основе предыдущих

### 2. **Улучшение пользовательского опыта**
- Понятные заголовки вместо "Результаты запроса"
- Автоматические подписи с контекстом
- Пользователь понимает, что за данные
- Лучшая навигация по истории

### 3. **Автоматизация подписей**
- Не нужно вручную описывать каждую таблицу
- Автоматическое извлечение метаданных
- Консистентный стиль подписей
- Экономия времени разработчика

### 4. **Каталогизация результатов**
- Создание индекса ранее созданных таблиц
- LLM может ссылаться на конкретные таблицы
- Обеспечивает преемственность диалога
- Улучшает качество ответов

## Устойчивость к диалектам SQL

### Поддерживаемые конструкции:
- `FROM table` и `JOIN table`
- `SELECT column AS alias`
- `WHERE date BETWEEN 'start' AND 'end'`
- `LIMIT n`
- Многострочные запросы
- Кавычки и бэктики в именах
- Сложные алиасы и функции

### Обработка ошибок:
- Fallback на DataFrame при неудачном парсинге
- Ограничение количества колонок (максимум 10)
- Безопасная обработка `None` значений
- Устойчивость к некорректному SQL

## Производительность

- **Временная сложность:** O(n) где n - длина SQL
- **Пространственная сложность:** O(k) где k - количество элементов
- Минимальные накладные расходы
- Кэширование результатов в `session_state`

## Связанные функции

- **`_tables_index_hint()`** - использует для каталогизации
- **`_render_result()`** - использует для подписей
- **`_push_result()`** - сохраняет метаданные
- **`_table_number_for()`** - нумерация таблиц

## Критическая важность

Эта функция является **фундаментальной** для:
- Создания понятного пользовательского интерфейса
- Обеспечения контекста для LLM
- Автоматизации создания подписей
- Улучшения пользовательского опыта
- Каталогизации результатов

**Без неё приложение было бы "глухим" - не помнило бы контекст и не могло бы строить на предыдущих результатах!**

## Практический пример использования

```python
# Пользователь делает запрос
user_input = "Покажи топ 5 городов по пользователям за январь"

# Генерируется SQL
sql = "SELECT city, count(*) as user_count FROM users WHERE created_at BETWEEN '2024-01-01' AND '2024-01-31' GROUP BY city ORDER BY user_count DESC LIMIT 5"

# Функция извлекает метаданные
info = _extract_sql_info(sql, df)
# Результат: {"tables": ["users"], "columns": ["city", "user_count"], "period": "2024-01-01 — 2024-01-31", "limit": 5}

# Создается умный заголовок
title = f"Топ {info['limit']} по «{info['columns'][0]}»"  # "Топ 5 по «city»"

# Показывается подпись
st.caption(f"Источник: {info['tables'][0]}. Период: {info['period']}.")

# LLM получает контекст для новых запросов
context = f"Предыдущий запрос: таблица {info['tables'][0]}, колонки {info['columns']}, период {info['period']}"
```
